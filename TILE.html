<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tile Flip Challenge</title>
    <style>
        /* Basic styling for the game */
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 0;
            padding: 0;
            height: 100vh;
            background-image: url('https://i.pinimg.com/736x/e3/a4/48/e3a4482bff09d997f675af868e43ff2b.jpg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            
        }

        h1 {
            margin-top: 5px;
            color: white;
        }

        .game-container {
            display: grid;
            grid-template-columns: repeat(6, 90px);
            gap: 5px;
            justify-content: center;
            margin: 50px auto;
            position: relative;
            overflow: hidden; /* Hide fruits overflowing */
        }

        .tile {
            width: 90px;
            height: 90px;
            background-image: url('./PNGFILE/TILE.png');
            background-size: cover;
            background-position: center;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: transform 0.3s ease;
            position: relative;
            z-index: 2; /* Make sure tiles are above fruits */
        }

        .tile:active {
            transform: scale(0.9);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
        }

        .tile.revealed {
            background-color: #f5faf6;
            cursor: default;
            background-image: none;
        }

        .tile.matched {
            background-color: #90ee90;
            cursor: default;
            background-image: none;
        }

        /* Fruit bounce animation */
        .fruit {
            position: absolute;
            z-index: 1; /* Make sure fruits are behind the tiles */
            animation: bounce 10s infinite ease-in-out;
        }

        /* Keyframes for dynamic bouncing animation */
        @keyframes bounce {
            0% {
                transform: translate(var(--start-x), var(--start-y));
            }
            25% {
                transform: translate(var(--end-x), var(--end-y));
            }
            50% {
                transform: translate(var(--start-x), var(--end-y));
            }
            75% {
                transform: translate(var(--end-x), var(--start-y));
            }
            100% {
                transform: translate(var(--start-x), var(--start-y));
            }

            50% {
                /* Switch to another direction for the second bounce */
                transform: translate(var(--bounce-end-x), var(--bounce-end-y));
            }

            100% {
                /* Bring it back to the original position with a twist */
                transform: translate(var(--bounce-start-x), var(--bounce-start-y));
            }
        }

    </style>
</head>
<body>
    <h1>Tile Flip Challenge</h1>
    <div class="game-container" id="gameContainer"></div>

    <script>
        // Array of symbols to be used for the tiles
        const symbols = ['ğŸ', 'ğŸŒ', 'ğŸ‡', 'ğŸ‰', 'ğŸ’', 'ğŸ“', 'ğŸ', 'ğŸ¥', 'ğŸ‘', 
                         'ğŸ¥­', 'ğŸ‹', 'ğŸ', 'ğŸ', 'ğŸ¥¥', 'ğŸ¥•', 'ğŸŒ½', 'ğŸ…', 'ğŸ†'];

        // Variables to hold the state of the game
        let tiles, gameContainer, firstTile = null, secondTile = null, matches = 0, gameStarted = false, totalPairs;

        // Initialize the game (either load saved progress or start a new game)
        function initializeGame() {
            const savedState = localStorage.getItem('tileFlipGameState');
            if (savedState) {
                loadGameProgress(); // Load saved progress
            } else {
                startNewGame(); // Start a new game
            }
            addFruits(); // Add bouncing fruits behind the tiles
        }

        // Start a new game by resetting variables and generating new tiles
        function startNewGame() {
            matches = 0;
            gameStarted = true;
            const selectedSymbols = symbols.sort(() => 0.5 - Math.random()).slice(0, 9); // Pick a random subset of symbols
            tiles = [...selectedSymbols, ...selectedSymbols].sort(() => 0.5 - Math.random()); // Create pairs and shuffle
            totalPairs = selectedSymbols.length;
            renderTiles(); // Render the tiles on the page
        }

        // Render the tiles on the game board
        function renderTiles() {
            gameContainer = document.getElementById('gameContainer');
            gameContainer.innerHTML = ''; // Clear the container
            tiles.forEach((symbol, index) => {
                const tile = createTile(symbol, index); // Create each tile
                gameContainer.appendChild(tile); // Add tile to the container
            });
        }

        // Create a single tile element
        function createTile(symbol, index) {
            const tile = document.createElement('div');
            tile.classList.add('tile');
            tile.dataset.symbol = symbol; // Store the symbol as a dataset attribute
            tile.dataset.index = index; // Store the index as a dataset attribute
            tile.addEventListener('click', () => handleTileClick(tile)); // Add click event listener
            return tile;
        }

        // Handle the logic when a tile is clicked
        function handleTileClick(tile) {
            // Ignore click if the game isn't started, tile is already revealed/matched, or another tile is in progress
            if (!gameStarted || tile.classList.contains('revealed') || tile.classList.contains('matched') || secondTile) {
                return;
            }

            tile.classList.add('revealed'); // Mark the tile as revealed
            tile.textContent = tile.dataset.symbol; // Show the symbol on the tile

            if (!firstTile) {
                firstTile = tile; // Set the first tile
            } else {
                secondTile = tile; // Set the second tile
                if (firstTile.dataset.symbol === secondTile.dataset.symbol) {
                    // If the two tiles match
                    firstTile.classList.add('matched');
                    secondTile.classList.add('matched');
                    firstTile = null;
                    secondTile = null;
                    matches++; // Increase the match count
                    checkWin(); // Check if the game is won
                } else {
                    // If the two tiles don't match
                    setTimeout(() => {
                        firstTile.classList.remove('revealed');
                        firstTile.textContent = '';
                        secondTile.classList.remove('revealed');
                        secondTile.textContent = '';
                        firstTile = null;
                        secondTile = null;
                    }, 1000); // Flip tiles back after a delay
                }
            }
            saveGameProgress(); // Save the game state
        }

        // Check if the player has won the game
        function checkWin() {
            if (matches === totalPairs) {
                setTimeout(() => {
                    alert('Congratulations! You won!'); // Display a win message
                    startNewGame(); // Start a new game
                }, 500);
            }
        }

        // Save the current game state to localStorage
        function saveGameProgress() {
            const gameState = {
                tiles: tiles,
                matches: matches,
                gameStarted: gameStarted,
                totalPairs: totalPairs
            };
            localStorage.setItem('tileFlipGameState', JSON.stringify(gameState));
        }

        // Load the game state from localStorage
        function loadGameProgress() {
            const savedState = JSON.parse(localStorage.getItem('tileFlipGameState'));
            tiles = savedState.tiles; // Load tiles
            matches = savedState.matches; // Load match count
            gameStarted = savedState.gameStarted; // Load game status
            totalPairs = savedState.totalPairs; // Load total pairs
            renderTiles(); // Render the tiles
        }

        // Add fruit elements that will bounce behind the tiles with customized sizes and random bounce paths
        function addFruits() {
            const fruits = ['ğŸ', 'ğŸŒ', 'ğŸ‡', 'ğŸ‰', 'ğŸ’', 'ğŸ“', 'ğŸ', 'ğŸ¥', 'ğŸ‘', 
                            'ğŸ¥­', 'ğŸ‹', 'ğŸ', 'ğŸ', 'ğŸ¥¥', 'ğŸ¥•', 'ğŸŒ½', 'ğŸ…', 'ğŸ†'];

            const fruitSizes = {
                'ğŸ': '6rem',  // Apple
                'ğŸŒ': '3rem',  // Banana
                'ğŸ‡': '2.5rem',  // Grapes
                'ğŸ‰': '3.5rem',  // Watermelon
                'ğŸ’': '2rem',  // Cherry
                'ğŸ“': '2rem',  // Strawberry
                'ğŸ': '3rem',  // Pineapple
                'ğŸ¥': '2.5rem', // Kiwi
                'ğŸ‘': '6rem',  // Peach
                'ğŸ¥­': '3rem',  // Mango
                'ğŸ‹': '2.5rem',  // Lemon
                'ğŸ': '2.5rem',  // Green Apple
                'ğŸ': '2.5rem',  // Pear
                'ğŸ¥¥': '3rem',  // Coconut
                'ğŸ¥•': '2rem',  // Carrot
                'ğŸŒ½': '3rem',  // Corn
                'ğŸ…': '2.5rem',  // Tomato
                'ğŸ†': '2rem'   // Eggplant
            };

            for (let i = 0; i < 50; i++) { // Create 50 fruits
                const fruit = fruits[Math.floor(Math.random() * fruits.length)];
                const fruitDiv = document.createElement('div');
                fruitDiv.classList.add('fruit');
                fruitDiv.textContent = fruit;

                // Apply size based on the fruit type
                fruitDiv.style.fontSize = fruitSizes[fruit] || '2.5rem'; // Default size if not specified

                // Random initial position for each fruit
                const randomX = Math.random() * window.innerWidth;
                const randomY = Math.random() * window.innerHeight;

                // Generate additional random bounce coordinates for second bounce
                const bounceStartX = randomX + (Math.random() * 100 - 50); // New starting point for bounce direction
                const bounceStartY = randomY + (Math.random() * 100 - 50); // New Y direction
                const bounceEndX = randomX + (Math.random() * 100 - 50); // New ending point for bounce
                const bounceEndY = randomY + (Math.random() * 100 - 50); // New Y direction

                // Apply dynamic CSS properties for bounce animation
                fruitDiv.style.setProperty('--start-x', `${randomX}px`);
                fruitDiv.style.setProperty('--start-y', `${randomY}px`);
                fruitDiv.style.setProperty('--end-x', `${randomX + (Math.random() * 200 - 100)}px`);
                fruitDiv.style.setProperty('--end-y', `${randomY + (Math.random() * 200 - 100)}px`);

                fruitDiv.style.setProperty('--bounce-start-x', `${bounceStartX}px`);
                fruitDiv.style.setProperty('--bounce-start-y', `${bounceStartY}px`);
                fruitDiv.style.setProperty('--bounce-end-x', `${bounceEndX}px`);
                fruitDiv.style.setProperty('--bounce-end-y', `${bounceEndY}px`);

                gameContainer.appendChild(fruitDiv);
            }
        }

        // Initialize the game when the page loads
        window.onload = initializeGame;
    </script>
</body>
</html>
